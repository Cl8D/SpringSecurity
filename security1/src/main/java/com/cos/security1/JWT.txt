<JWT 이론 설명>
= Json Web Token

====================

## 세션(Sesion)

<세션이란?>
유저가 웹 브라우저를 열고, 어떠한 주소창을 통해 접속했다면 GET으로 보내진다.
이때 서버는 .html을 리턴해주는데, HTTP의 header에 쿠키를 담아준다.
이때 쿠키는 세션ID를 하나 만들어서 (ex. 1234) 담아서 준다.

그러면 웹 브라우저는 쿠키를 받아서 세션 ID와 함께 저장한다.
=> 여기까지의 과정이 최초 요청 시 만들어지는 것.

두 번째 요청부터는 세션ID를 웹 브라우저가 달고 가기 때문에,
서버도 그때부터 해당 세션 ID를 그대로 반환해준다.

이때 이러한 세션ID의 역할은 이전에 왔던 통신인지 구분하는 역할이라고도 볼 수 있다.
서버는 세션 ID 목록을 가지고 있어야 하며, 어떠한 통신인지 비교해야 하는 것.

대충 요약하자면,
최초 요청 -> 세션 목록에 세션 정보 담아둔 뒤 웹 브라우저에게 반환
-> 웹 브라우저는 해당 세션 ID 저장하고 있음
두 번째 요청 -> 세션 ID도 함께 전달 -> 서버는 세션 목록에서 해당 ID가 존재하는지 확인
-> 존재한다면 최초 요청과 동일한 사용자임을 자각 가능.

<세션의 생명 주기>
1) 서버 쪽에서 세션 목록에서 해당 세션의 값을 없앨 때
2) 사용자가 웹 브라우저를 종료시킬 때
3) 일정 시간이 지났을 때(ex. 30분) 세션 목록에서 알아서 제거됨.

- 세션은 보통 로그인 요청 (인증) 시 많이 사용된다.
클라이언트 최초 요청 -> 서버는 세션 저장소에 세션 ID 생성(ex. 1234)
-> 서버는 응답 시 헤더에 세션 ID(1234)를 함께 돌려준다.
-> 클라이언트는 세션ID 1234를 저장하고 있다.
만약 로그인 요청을 날린다면 (id, pwd), 서버는 이를 DB에 값이 있는지 확인함.
-> 만약 존재한다면 세션은 아까 해당하는 세션 ID의 저장소에 user 정보를 저장해둠.
-> 로그인 성공 시 보통 메인 페이지로 리턴이 됨.

만약 그 이후 클라이언트가 유저 정보를 요청했다면, (이때 세션 id인 1234를 함께 전달)
서버는 세션에서 세션ID 정보를 바탕으로 유저 정보를 확인한 뒤,
DB에 사용자 정보를 응답받아 클라이언트에게 전달한다.

==> 즉, 세션을 통해 민감한 정보에 대한 접근이 가능해진다.

<세션의 단점>
클라이언트가 요청 시 서버에서 응답을 할 텐데, 이때 클라이언트 수가 엄청 많다고 가정하자.
이때 동시 접속자 수가 많아지면(300명) 서버를 여러 대를 두게 된다. (100명씩 수용 가능한 서버 3대)
이런 식으로 부하를 분산시키는 게 로드 밸런싱.

이러한 로드 밸런싱이 일어날 때,
1) 첫 요청으로 로그인 요청을 서버2에게 했다. 마찬가지로 서버2는 세션 만들어서 응답을 해줌.
2) 그 다음 요청으로 서버2에게 세션 id와 함께 정보 요청 -> 성공
3) 그러나, 로드 밸런싱으로 인해 서버3에게 넘어감.
이때 서버3에게 이 응답은 최초 응답이라고 생각하고 또 세션을 생성하게 된다.

그래서 해당 요청은 서버2에만 들어올 수 있도록 하거나,
세션 정보를 모든 서버에게 복사하는 식으로 진행할 수 있다.
아니면, 서버 3대가 하나의 db를 공유하여 사용하여 세션값을 공유하는 것이다.
-> 그러나, db에 넣으면 하드디스크에서 뒤져야 하기 때문에 속도가 매우 느려진다.
(보통은 RAM에서 찾아서 속도가 빠르지만... HDD까지 갔다가 전송되는 식으로 하면 느려짐.
IO가 일어나면 아무튼 속도가 매우 느려져서... 원판을 돌면서 데이터를 찾다 보니까 전체를 다 뒤져야 해서 느림)

그래서 보통! DB 대신에 메모리 공유 서버를 사용한다.
이때는 하드 대신 램만 있어서 속도 문제를 해결할 수 있게 된다.
(ex. Redis)

JWT는, 세션을 해결하기 위한 도구라고 할 수 있다.

================================

## TCP
OSI 7계층.

물리 계층 - 데이터링크 - 네트워크 - 전송 - 세션 - 표현 - 응용 계층.

보통 통신이 일어나면 응용 -> 물리 계층으로 쭉 내려간 다음,
다시 상대방한테는 물리 -> 응용을 통해 전달된다.

ex) LoL에서 야스오에게 궁을 줌
응용 -> 롤 프로그램, 궁 데이터
표현 -> 암호화, 압축
세션 -> 인증이 되어 있는지 체크
전송 -> TCP(신뢰성 있는 통신. 보낸 데이터가 잘 갔는지 확인함-ACK, 속도 느림)
        / UDP(보내고 싶은 데이터 무작위로 보냄. 신뢰성 x) 통신 결정
네트워크 -> IP (상대방을 찾기 위함)
데이터링크 -> IP로 도달한 목적지에서 뭐 여러 공유기가 있다고 한다면, 목적지 공유기를 찾아가는 과정
물리 -> 광케이블 같은 전기선.

- 웹은, 특히 TCP 통신을 한다.

================================

## CIA
Confidential - 기밀성 (보안 노출x)
Integrity - 무결성 (변경 방지)
Availability - 가용성 (인가된 사용자가 사용하는가)

기밀성 유지 => 암호화하기 => 가용성도 유지됨
그러나 암호화된 것 자체를 가져가서 바꿔챌 수도 있음 -> 무결성 깨짐
-> 그래서 아예 가져올 수 없도록 해버려야 함.

만약 문서를 A라는 열쇠로 잠갔다면, 상대도 A라는 열쇠를 가지고 있어야 함.
1) 첫 번째 문제 : 이때 열쇠를 어떻게 하면 안전하게 전달할 수 있을까?

또한, a-c-b가 있을 때
a-b가 서로 협약해야 한다면 a->b에게 문서를 전달해야 함.
이때 b->a로도 문서를 잘 받았다는 응답을 보내줘야 한다.
그러나, c가 가로채서 c->a로도 응답을 보낼 수도 있는 것.
혹은 c가 문서를 위조해버리든지, 아니면 b의 응답을 c가 가로채서 전달하지 않도록 하든지...

2) 두 번째 문제 : 문서가 누구로부터 왔는지도 알아야 함

================================

## RSA (암호화 기법)
pubKey, priKey가 존재함.
pubKey는 공개키, priKey는 개인키.
A, B가 있고 해커가 있다고 가정했을 때
A->B에게 데이터를 전달하고 싶음.

- cf) 키 한 개로 한다면 대칭키.

이때 A는 B의 공개키로 데이터를 암호화해서 보낸다.
이때 B는 이 메시지를 받아서 B의 개인키로 풀 수 있게 된다.
이러면 C가 가로채더라도 B의 공개키로 잠겨있기 때문에 B의 개인키를 몰라서 풀 수가 없게 된다.

=> 이러면 위에서 말했던 1)의 문제를 해결할 수 있다.

또, A->B에게 메시지를 보낼 때 A의 개인키로 암호화해서 보냈다고 해보자.
이때 이를 가로채면 A의 공개키를 통해 누구도 볼 수 있게 되지만,
이때 보내는 메시지가 딱히 중요한 메시지가 아닌
"A가 보낸 메시지"임을 알 수 있는 정도의 메시지라면?
=> 즉, A의 공개키로 열 수 있다면 A의 개인키로 암호화했음을 의미하니까
= 이는 곧 서명, 인증이며! 즉 A가 보냈음을 보장할 수 있게 되는 것.

정리하자면,
공개키 암호화 -> 개인키 풀기 (암호화)
개인키 암호화 -> 공개키 풀기 (전자서명)
이라고 구분이 가능하다. 이게 바로 RSA.

A가 문서를 B의 공개키로 잠궜는데 C가 이를 가로채서 아예 그냥 버려버릴 수도 있으니까,
B의 공개키로 잠군 걸 A의 개인키로 잠궈서 문서를 보내버리는 것이다.

이러면 B의 입장으로는
1) A의 공개키로 열어보기 -> 이때 열리면 A가 보낸 게 보장되니까 인증 완료
2) 이후 B의 개인키로 열어보기 -> 문서 확인이 가능해짐. (안전하게 전달 가능)

즉, 위에서 말했던 두 가지 문제를 다 해결할 수 있게 되는 것!!

==============================

## RFC 문서
JWT는 RSA 방식을 사용한다. (jwt.io/introduction)

두 개의 연구망이 서로 통신을 주고받을 때, 약속된 규칙이 필요한데
그게 바로 RFC 문서.
= 이러한 약속된 문서 방식을 '프로토콜'이라고 한다.

이러한 네트워크 망이 엄청 커진 게 www (world wide web)
인터넷은 RFC 문서로 만들어져 있으며, 그리고 이러한 걸 http 프로토콜이라고 한다.

JWT는 RFC 7519에 정의됨.

===========================

## JWT 구조
-> 정보를 JSON 객체로 안전하게 전송하기 위한 RFC 7519 표준이며,
이러한 정보는 디지털 서명이 되어 있기 때문에 신뢰 가능하다.
JWT는 서명된 웹 토큰에 중점 = 즉, 본인이 썼다는 걸 보장하는 '서명' 용도.
토큰 안에는 무결성이 보장되어 있다.

<구조>
xxxxx(header)-yyyyy(payload)-zzzzz(signature)

1) header = JSON 형식
alg(어떤 알고리즘을 사용했는지) - typ (타입)으로 구성되어 있음.
이러한 json은 Base64로 인코딩 되어 있음. (암, 복호화 가능)


2) payload
- 등록된 클레임 / 개인 클레임

등록된 클레임
- 필수는 아니지만 권장.
- iss(발행자), exp(만료 시간), sub(주제), aud (청중)으로 구성

개인 클레임)
- 서로 정보를 주고받기 위해 공유된 사용자 지정 클레임.
- 개발자가 직접 만들어낼 수 있음.


3) signature
header, payload, secret를 HMAC으로 암호화하기


<설명>
어떠한 서버가 있고, 클라이언트가 있다.
이때 클라이언트가 서버에게 id, pwd를 전송하였다.
서버는 이러한 로그인 시도를 원래는 세션을 만들었지만,
이제는 JWT를 만들어낼 예정.

이때 서버는 header, payload, signature를 만든다.
header에는 HS256으로 서명했던 정보가, payload에는 username:"hi"라고 있다고 가정해보자.
signature에는 header + payload + 서버만 알고 있는 secret key는 hs256으로 암호화한 게 들어간다.

HS256은 HMAC 방식으로 SHA256 암호화(해시, 복호화 불가한 키 값)를 한 것이다.
이때 HMAC은 secret key를 포함한 암호화 방식이기 때문에,
결국 HS256은 HMAC + SHA256 방식이라고 할 수 있다.

그리고, 이렇게 완성된 header / payload / signature 각각을
base64로 인코딩을 한다.
-> 이를 클라이언트에게 돌려준다.

클라이언트는 이를 받아서 로컬 스토리지 영역이 있는데 거기에 집어넣어둔다.
후에 클라이언트가 서버에게 개인정보를 요청한다면, JWT와 함께 전송한다.
서버는 이를 JWT가 신뢰할 수 있는 토큰인지 검증 작업이 필요한데,
본인이 알고 있는 header, payload, secret으로 HS256 암호화 작업을 진행한 뒤,
클라이언트가 보내준 signature 값과 비교하여 같은지 판단한다.
같으면 이전에 왔던 애라는 걸 인증 완료하는 것.
이후 payload에 저장된 뭐... username 정보를 리턴하는 식으로 동작함.


근데, HS256 방식 대신에 RSA 방식을 사용한다면,
header에는 RSA, payload에는 username="hi"를 넣어준다.
RSA에는 공개키와 개인키가 존재하기 때문에,
signature 생성 시 header + payload를 서버의 개인키로 잠그는 것.

이러한 토큰을 클라이언트에게 전송한 뒤, 다시 클->서로 정보 요청과 토큰을 함께 전송한다면
이때 서버가 이를 검증할 때 공개키로 서명값을 검증하면 되는 것이다.
